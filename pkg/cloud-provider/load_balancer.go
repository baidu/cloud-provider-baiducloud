/*
Copyright 2018 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package cloud_provider

import (
	"context"
	"fmt"
	"net"
	"strings"
	"time"

	"github.com/golang/glog"
	"k8s.io/api/core/v1"
	"k8s.io/kubernetes/pkg/cloudprovider"

	"k8s.io/cloud-provider-baiducloud/pkg/sdk/blb"
	"k8s.io/cloud-provider-baiducloud/pkg/sdk/eip"
	"k8s.io/cloud-provider-baiducloud/pkg/sdk/util"
	"k8s.io/cloud-provider-baiducloud/pkg/sdk/vpc"
)

type AnnotationRequest struct {
	LoadBalancerId          string
	LoadBalancerInternalVpc string
}

// GetLoadBalancer returns whether the specified load balancer exists, and
// if so, what its status is.
// Implementations must treat the *v1.Service parameter as read-only and not modify it.
// Parameter 'clusterName' is the name of the cluster as presented to kube-controller-manager
func (bc *BCECloud) GetLoadBalancer(ctx context.Context, clusterName string, service *v1.Service) (status *v1.LoadBalancerStatus, exists bool, err error) {
	bc.WorkAround(service)
	_, request := ExtractAnnotationRequest(service)

	if len(request.LoadBalancerId) == 0 {
		return nil, false, nil
	}
	lb, exists, err := bc.getBCELoadBalancerById(request.LoadBalancerId)
	if err != nil {
		return nil, false, err
	}
	if !exists {
		return nil, false, nil
	}

	var ip string
	if request.LoadBalancerInternalVpc == "true" {
		ip = lb.Address
	} else {
		ip = lb.PublicIp // EIP
	}
	glog.V(4).Infof("GetLoadBalancer ip: %s", ip)

	return &v1.LoadBalancerStatus{Ingress: []v1.LoadBalancerIngress{{IP: ip}}}, true, nil
}

// EnsureLoadBalancer creates a new load balancer 'name', or updates the existing one. Returns the status of the balancer
// Implementations must treat the *v1.Service and *v1.Node
// parameters as read-only and not modify them.
// Parameter 'clusterName' is the name of the cluster as presented to kube-controller-manager
func (bc *BCECloud) EnsureLoadBalancer(ctx context.Context, clusterName string, service *v1.Service, nodes []*v1.Node) (*v1.LoadBalancerStatus, error) {
	glog.V(4).Infof("EnsureLoadBalancer(%v, %v, %v, %v, %v, %v, %v, %v, %v)",
		clusterName, service.Namespace, service.Name, bc.Region, service.Spec.LoadBalancerIP, service.Spec.Ports,
		service.Annotations)
	bc.WorkAround(service)
	_, request := ExtractAnnotationRequest(service)
	if len(service.Spec.Ports) == 0 {
		return nil, fmt.Errorf("requested load balancer with no ports")
	}
	for _, port := range service.Spec.Ports {
		if port.Protocol != v1.ProtocolTCP {
			return nil, fmt.Errorf("only TCP LoadBalancer is supported for Baidu CCE")
		}
	}

	// (1) BLB
	var lb *blb.LoadBalancer
	var err error
	if len(request.LoadBalancerId) == 0 { // blb not exist, create one and update annotation
		glog.V(4).Infoln("EnsureLoadBalancer create blb!")
		vpcId, subnetId, err := bc.getVpcInfoForBLB()
		if err != nil {
			return nil, fmt.Errorf("Can't get VPC info for BLB: %v\n", err)
		}
		args := blb.CreateLoadBalancerArgs{
			Name:     bc.ClusterID + "/" + getServiceName(service),
			VpcID:    vpcId,
			SubnetID: subnetId,
			Desc:     "auto generated by cce:" + bc.ClusterID,
		}
		resp, err := bc.clientSet.Blb().CreateLoadBalancer(&args)
		if err != nil {
			return nil, err
		}
		glog.V(4).Infof("EnsureLoadBalancer create blb success, BLB name: %s, BLB id: %s, BLB address: %s.\n", resp.Name, resp.LoadBalancerId, resp.Address)
		argsDesc := blb.DescribeLoadBalancersArgs{
			LoadBalancerId: resp.LoadBalancerId,
		}
		lbs, err := bc.clientSet.Blb().DescribeLoadBalancers(&argsDesc)
		if err != nil {
			return nil, err
		}
		if len(lbs) != 1 {
			glog.V(4).Infof("EnsureLoadBalancer create blb failed: len(lbs) != 1")
			return nil, fmt.Errorf("EnsureLoadBalancer create blb failed: len(lbs) != 1\n")
		}
		lb = &lbs[0]
		if service.Annotations == nil {
			service.Annotations = make(map[string]string)
		}
		service.Annotations[ServiceAnnotationLoadBalancerId] = lb.BlbId
	} else { // blb already exist, get info from cloud
		var exists bool
		lb, exists, err = bc.getBCELoadBalancerById(request.LoadBalancerId)
		if err != nil {
			return nil, err
		}
		if !exists {
			return nil, fmt.Errorf("EnsureLoadBalancer getBCELoadBalancerById failed, target blb not exist, blb id: %v", request.LoadBalancerId)
		}
		glog.V(4).Infoln("EnsureLoadBalancer: blb already exists: %v", lb)
	}
	lb, err = bc.waitForLoadBalancer(lb)
	if err != nil {
		return nil, err
	}

	// 更新监听设置
	glog.V(2).Infoln("EnsureLoadBalancer: reconcileListeners!")
	err = bc.reconcileListeners(service, lb)
	if err != nil {
		return nil, err
	}
	lb, err = bc.waitForLoadBalancer(lb)
	if err != nil {
		return nil, err
	}

	// 更新后端服务器
	glog.V(2).Infoln("EnsureLoadBalancer: reconcileBackendServers!")
	err = bc.reconcileBackendServers(nodes, lb)
	if err != nil {
		return nil, err
	}
	lb, err = bc.waitForLoadBalancer(lb)
	if err != nil {
		return nil, err
	}

	// (2) EIP
	if request.LoadBalancerInternalVpc == "true" {
		glog.V(4).Infof("EnsureLoadBalancer: use LoadBalancerInternalVpc, EXTERNAL-IP is %s", lb.Address)
		return &v1.LoadBalancerStatus{Ingress: []v1.LoadBalancerIngress{{IP: lb.Address}}}, nil
	}
	pubIP := lb.PublicIp
	loadBalancerIP := service.Spec.LoadBalancerIP
	if len(loadBalancerIP) == 0 { // not set LoadBalancerIP
		if len(pubIP) == 0 { // blb not bind eip
			glog.V(2).Infoln("EnsureLoadBalancer: createEIP!")
			pubIP, err = bc.createEIP(lb)
			if err != nil {
				if pubIP != "" {
					args := eip.EipArgs{
						Ip: pubIP,
					}
					bc.clientSet.Eip().DeleteEip(&args)
				}
				return nil, err
			}
		} else { // blb already bind eip
			glog.V(4).Infoln("EnsureLoadBalancer: blb's eip already exists!")
		}
	} else { // set LoadBalancerIP
		glog.V(4).Infof("EnsureLoadBalancer: Try to bind Custom LoadBalancerIP %s to BLB %s.\n", loadBalancerIP, lb.BlbId)
		if len(pubIP) == 0 { // blb not bind eip
			// check eip status
			argsGet := eip.GetEipsArgs{
				Ip: loadBalancerIP,
			}
			eips, err := bc.clientSet.Eip().GetEips(&argsGet)
			if err != nil {
				return nil, err
			}
			if len(eips) == 0 {
				err = fmt.Errorf("EnsureLoadBalancer: EIP %s not Exist\n", loadBalancerIP)
				return nil, err
			} else {
				eipStatus := eips[0].Status
				for index := 0; (index < 10) && (eipStatus != "available"); index++ {
					glog.V(4).Infof("Eip: %s is not available, retry:  %d", loadBalancerIP, index)
					time.Sleep(10 * time.Second)
					eips, err := bc.clientSet.Eip().GetEips(&argsGet)
					if err != nil {
						return nil, err
					}
					eipStatus = eips[0].Status
				}
				glog.V(4).Infof("Eip status is: %s", eipStatus)
			}

			// bind
			lb.Status = "unknown" // add here to do loop
			for index := 0; (index < 10) && (lb.Status != "available"); index++ {
				glog.V(4).Infof("BLB: %s is not available, retry:  %d", lb.BlbId, index)
				time.Sleep(10 * time.Second)
				newlb, exist, err := bc.getBCELoadBalancerById(lb.BlbId)
				if err != nil {
					glog.V(4).Infof("getBCELoadBalancer error: %s", lb.BlbId)
					return nil, err
				}
				if !exist {
					glog.V(4).Infof("getBCELoadBalancer not exist: %s", lb.BlbId)
					return nil, fmt.Errorf("BLB not exists:%s", lb.BlbId)
				}
				lb = newlb
				glog.V(4).Infof("BLB status is : %s", lb.Status)
			}
			argsBind := &eip.BindEipArgs{
				Ip:           loadBalancerIP,
				InstanceId:   lb.BlbId,
				InstanceType: eip.BLB,
			}
			glog.V(4).Infof("BindEip:  %v", argsBind)
			glog.V(4).Infof("Bind BLB: %v", lb)
			err = bc.clientSet.Eip().BindEip(argsBind)
			if err != nil {
				glog.V(4).Infof("BindEip error: %v", err)
				return nil, err
			}
			lb.PublicIp = loadBalancerIP
			pubIP = loadBalancerIP
			glog.V(4).Infof("EnsureLoadBalancer: Bind EIP to BLB success.")
		} else { // blb already bind eip
			if pubIP == loadBalancerIP { // blb bind correct LoadBalancerIP
				glog.V(4).Infof("EnsureLoadBalancer: BLB %s already bind EIP %s.\n", lb.BlbId, pubIP)
			} else { // blb not bind correct LoadBalancerIP, need update
				glog.V(4).Infof("EnsureLoadBalancer: BLB %s already bind EIP %s, but need updating to %s.\n", lb.BlbId, pubIP, loadBalancerIP)
				argsGet := eip.GetEipsArgs{
					Ip: pubIP,
				}
				eips, err := bc.clientSet.Eip().GetEips(&argsGet)
				if err != nil {
					return nil, err
				}
				if len(eips) > 0 {
					unbindArgs := eip.EipArgs{
						Ip: pubIP,
					}
					err := bc.clientSet.Eip().UnbindEip(&unbindArgs)
					if err != nil {
						glog.V(4).Infof("Unbind Eip error : %s", err.Error())
						return nil, err
					}
				}
				// bind
				lb.Status = "unknown" // add here to do loop
				for index := 0; (index < 10) && (lb.Status != "available"); index++ {
					glog.V(4).Infof("BLB: %s is not available, retry:  %d", lb.BlbId, index)
					time.Sleep(10 * time.Second)
					newlb, exist, err := bc.getBCELoadBalancerById(lb.BlbId)
					if err != nil {
						glog.V(4).Infof("getBCELoadBalancer error: %s", lb.BlbId)
						return nil, err
					}
					if !exist {
						glog.V(4).Infof("getBCELoadBalancer not exist: %s", lb.BlbId)
						return nil, fmt.Errorf("BLB not exists:%s", lb.BlbId)
					}
					lb = newlb
					glog.V(4).Infof("BLB status is : %s", lb.Status)
				}
				argsBind := &eip.BindEipArgs{
					Ip:           loadBalancerIP,
					InstanceId:   lb.BlbId,
					InstanceType: eip.BLB,
				}
				glog.V(4).Infof("BindEip:  %v", argsBind)
				glog.V(4).Infof("Bind BLB: %v", lb)
				err = bc.clientSet.Eip().BindEip(argsBind)
				if err != nil {
					glog.V(4).Infof("BindEip error: %v", err)
					return nil, err
				}
				lb.PublicIp = loadBalancerIP
				pubIP = loadBalancerIP
			}
		}
	}
	glog.V(4).Infof("EnsureLoadBalancer: EXTERNAL-IP is %s", pubIP)
	return &v1.LoadBalancerStatus{Ingress: []v1.LoadBalancerIngress{{IP: pubIP}}}, nil
}

// UpdateLoadBalancer updates hosts under the specified load balancer.
// Implementations must treat the *v1.Service and *v1.Node
// parameters as read-only and not modify them.
// Parameter 'clusterName' is the name of the cluster as presented to kube-controller-manager
func (bc *BCECloud) UpdateLoadBalancer(ctx context.Context, clusterName string, service *v1.Service, nodes []*v1.Node) error {
	_, err := bc.EnsureLoadBalancer(ctx, clusterName, service, nodes)
	return err
}

// EnsureLoadBalancerDeleted deletes the specified load balancer if it
// exists, returning nil if the load balancer specified either didn't exist or
// was successfully deleted.
// This construction is useful because many cloud providers' load balancers
// have multiple underlying components, meaning a Get could say that the LB
// doesn't exist even if some part of it is still laying around.
// Implementations must treat the *v1.Service parameter as read-only and not modify it.
// Parameter 'clusterName' is the name of the cluster as presented to kube-controller-manager
func (bc *BCECloud) EnsureLoadBalancerDeleted(ctx context.Context, clusterName string, service *v1.Service) error {
	bc.WorkAround(service)
	_, request := ExtractAnnotationRequest(service)
	serviceName := getServiceName(service)
	glog.V(2).Infof("delete(%s): START clusterName=%q lbId=%q", serviceName, clusterName, request.LoadBalancerId)

	// reconcile logic is capable of fully reconcile, so we can use this to delete
	service.Spec.Ports = []v1.ServicePort{}

	lb, existsLb, err := bc.getBCELoadBalancerById(request.LoadBalancerId)
	glog.V(4).Infof("EnsureLoadBalancerDeleted getBCELoadBalancer : %s", lb.BlbId)
	if err != nil {
		glog.V(4).Infof("EnsureLoadBalancerDeleted get error: %s", err.Error())
		return err
	}
	if !existsLb {
		glog.V(4).Infof("EnsureLoadBalancerDeleted: target blb not exist")
		return nil
	}
	// start delete blb and eip, delete blb first
	glog.V(4).Infof("Start delete BLB: %s", lb.BlbId)
	args := blb.DeleteLoadBalancerArgs{
		LoadBalancerId: lb.BlbId,
	}
	err = bc.clientSet.Blb().DeleteLoadBalancer(&args)
	if err != nil {
		return err
	}
	// delete EIP
	if lb.PublicIp != "" {
		if len(service.Spec.LoadBalancerIP) != 0 {
			glog.V(4).Infof("EnsureLoadBalancerDeleted: LoadBalancerIP is set, not delete EIP.")
			glog.V(2).Infof("delete(%s): FINISH", serviceName)
			return nil
		}
		glog.V(4).Infof("Start delete EIP: %s", lb.PublicIp)
		err = bc.deleteEIP(lb.PublicIp)
		if err != nil {
			return err
		}
	}
	glog.V(2).Infof("delete(%s): FINISH", serviceName)
	return nil
}

// 兼容老版本；不支持老版本则直接删除此部分
func (bc *BCECloud) WorkAround(service *v1.Service) {
	lb, exists, err := bc.getBCELoadBalancer(cloudprovider.GetLoadBalancerName(service))
	if err != nil {
		return
	}
	if !exists {
		return
	}
	if service.Annotations == nil {
		service.Annotations = make(map[string]string)
	}
	// TODO: 不会更新最终Service的annotaion，因为ip没变
	service.Annotations[ServiceAnnotationLoadBalancerId] = lb.BlbId
	glog.V(2).Infof("WorkAround for old version, lb: %v", lb)
}


func (bc *BCECloud) getBCELoadBalancer(name string) (lb *blb.LoadBalancer, exists bool, err error) {
	args := blb.DescribeLoadBalancersArgs{
		LoadBalancerName: name,
	}
	lbs, err := bc.clientSet.Blb().DescribeLoadBalancers(&args)
	if err != nil {
		glog.V(2).Infof("getBCELoadBalancer  blb not exists ! %v", args)
		return &blb.LoadBalancer{}, false, err
	}
	if len(lbs) != 1 {
		glog.V(2).Infof("getBCELoadBalancer len(lbs) != 1: %v", lbs)
		return &blb.LoadBalancer{}, false, fmt.Errorf("getBCELoadBalancer len(lbs) != 1: %v", lbs)
	}

	return &lbs[0], true, nil
}

func (bc *BCECloud) getBCELoadBalancerById(id string) (lb *blb.LoadBalancer, exists bool, err error) {
	args := blb.DescribeLoadBalancersArgs{
		LoadBalancerId: id,
	}
	lbs, err := bc.clientSet.Blb().DescribeLoadBalancers(&args)
	if err != nil {
		glog.V(2).Infof("getBCELoadBalancer blb %s not exists: %v", args.LoadBalancerId ,err)
		return &blb.LoadBalancer{}, false, err
	}
	if len(lbs) != 1 {
		glog.V(2).Infof("getBCELoadBalancer len(lbs) != 1: %v", lbs)
		return &blb.LoadBalancer{}, false, fmt.Errorf("getBCELoadBalancer len(lbs) != 1: %v", lbs)
	}
	return &lbs[0], true, nil
}

// This returns a human-readable version of the Service used to tag some resources.
// This is only used for human-readable convenience, and not to filter.
func getServiceName(service *v1.Service) string {
	return fmt.Sprintf("%s/%s", service.Namespace, service.Name)
}

// PortListener describe listener port
type PortListener struct {
	Port     int
	Protocol string
	NodePort int32
}

func (bc *BCECloud) reconcileListeners(service *v1.Service, lb *blb.LoadBalancer) error {
	expected := make(map[int]PortListener)
	// add expected ports
	for _, servicePort := range service.Spec.Ports {
		expected[int(servicePort.Port)] = PortListener{
			Port:     int(servicePort.Port),
			Protocol: string(servicePort.Protocol),
			NodePort: servicePort.NodePort,
		}
	}
	// delete or update unexpected ports
	all, err := bc.getAllListeners(lb)
	if err != nil {
		return err
	}
	var deleteList []PortListener
	for _, l := range all {
		port, ok := expected[l.Port]
		if !ok {
			// delete listener port
			// add to deleteList
			deleteList = append(deleteList, l)
		} else {
			if l != port {
				// update listener port
				err := bc.updateListener(lb, port)
				if err != nil {
					return err
				}
			}
			delete(expected, l.Port)
		}
	}
	// delete listener
	if len(deleteList) > 0 {
		err = bc.deleteListener(lb, deleteList)
		if err != nil {
			return err
		}
	}

	// create expected listener
	for _, pl := range expected {
		err := bc.createListener(lb, pl)
		if err != nil {
			return err
		}
	}
	return nil
}

func (bc *BCECloud) findPortListener(lb *blb.LoadBalancer, port int, proto string) (PortListener, error) {
	switch proto {
	case "HTTP":
	case "TCP":
		args := blb.DescribeTCPListenerArgs{
			LoadBalancerId: lb.BlbId,
			ListenerPort:   port,
		}
		ls, err := bc.clientSet.Blb().DescribeTCPListener(&args)
		if err != nil {
			return PortListener{}, err
		}
		if len(ls) < 1 {
			return PortListener{}, fmt.Errorf("there is no tcp listener blb:%s  port:%d", lb.BlbId, port)
		}
		return PortListener{
			Port:     ls[0].ListenerPort,
			NodePort: int32(ls[0].BackendPort),
			Protocol: proto,
		}, nil
	case "HTTPS":
	case "UDP":
	}
	return PortListener{}, fmt.Errorf("protocol not match: %s", proto)
}

func (bc *BCECloud) getAllListeners(lb *blb.LoadBalancer) ([]PortListener, error) {
	allListeners := []PortListener{}
	// add TCPlisteners
	args := blb.DescribeTCPListenerArgs{
		LoadBalancerId: lb.BlbId,
	}
	ls, err := bc.clientSet.Blb().DescribeTCPListener(&args)
	if err != nil {
		return nil, err
	}
	for _, listener := range ls {
		allListeners = append(allListeners, PortListener{
			Port:     listener.ListenerPort,
			Protocol: "TCP",
			NodePort: int32(listener.BackendPort),
		})
	}

	// add HTTPlisteners HTTPS UDP
	// TODO
	return allListeners, nil
}

func (bc *BCECloud) createListener(lb *blb.LoadBalancer, pl PortListener) error {
	switch pl.Protocol {
	case "HTTP":
	case "TCP":
		args := blb.CreateTCPListenerArgs{
			LoadBalancerId: lb.BlbId,
			ListenerPort:   pl.Port,
			BackendPort:    int(pl.NodePort),
			Scheduler:      "RoundRobin",
		}
		err := bc.clientSet.Blb().CreateTCPListener(&args)
		if err != nil {
			return err
		}
		return nil
	case "HTTPS":
	case "UDP":
	}
	return fmt.Errorf("CreateListener protocol not match: %s", pl.Protocol)
}

func (bc *BCECloud) updateListener(lb *blb.LoadBalancer, pl PortListener) error {
	switch pl.Protocol {
	case "HTTP":
	case "TCP":
		args := blb.UpdateTCPListenerArgs{
			LoadBalancerId: lb.BlbId,
			ListenerPort:   pl.Port,
			BackendPort:    int(pl.NodePort),
			Scheduler:      "RoundRobin",
		}
		err := bc.clientSet.Blb().UpdateTCPListener(&args)
		if err != nil {
			return err
		}
		return nil
	case "HTTPS":
	case "UDP":
	}
	return fmt.Errorf("updateListener protocol not match: %s", pl.Protocol)
}

func (bc *BCECloud) deleteListener(lb *blb.LoadBalancer, pl []PortListener) error {
	portList := []int{}
	for _, l := range pl {
		portList = append(portList, l.Port)
	}
	args := blb.DeleteListenersArgs{
		LoadBalancerId: lb.BlbId,
		PortList:       portList,
	}
	err := bc.clientSet.Blb().DeleteListeners(&args)
	if err != nil {
		return err
	}
	return nil
}

const DEFAULT_SERVER_WEIGHT = 100

func (bc *BCECloud) getAllBackendServer(lb *blb.LoadBalancer) ([]blb.BackendServer, error) {
	args := blb.DescribeBackendServersArgs{
		LoadBalancerId: lb.BlbId,
	}
	bs, err := bc.clientSet.Blb().DescribeBackendServers(&args)
	if err != nil {
		return nil, err
	}
	return bs, nil
}

func (bc *BCECloud) reconcileBackendServers(nodes []*v1.Node, lb *blb.LoadBalancer) error {
	expectedServer := make(map[string]string)
	for _, node := range nodes {
		splitted := strings.Split(node.Spec.ProviderID, "//")
		name := splitted[1]
		expectedServer[name] = node.ObjectMeta.Name
	}
	allBS, err := bc.getAllBackendServer(lb)
	if err != nil {
		return err
	}
	removeList := []string{}
	// remove unexpected servers
	for _, bs := range allBS {
		_, exists := expectedServer[bs.InstanceId]
		if !exists {
			removeList = append(removeList, bs.InstanceId)
		}
		delete(expectedServer, bs.InstanceId)
	}
	if len(removeList) > 0 {
		args := blb.RemoveBackendServersArgs{
			LoadBalancerId:    lb.BlbId,
			BackendServerList: removeList,
		}
		err = bc.clientSet.Blb().RemoveBackendServers(&args)
		if err != nil {
			return err
		}

	}
	addList := []blb.BackendServer{}
	// add expected servers
	for insID, nodeName := range expectedServer {
		addList = append(addList, blb.BackendServer{
			InstanceId: insID,
			Weight:     DEFAULT_SERVER_WEIGHT,
		})
		glog.V(4).Infof("add node %s", nodeName)
	}
	if len(addList) > 0 {
		args := blb.AddBackendServersArgs{
			LoadBalancerId:    lb.BlbId,
			BackendServerList: addList,
		}
		err = bc.clientSet.Blb().AddBackendServers(&args)
		if err != nil {
			return err
		}
	}
	return nil
}

func (bc *BCECloud) createEIP(lb *blb.LoadBalancer) (string, error) {
	bill := &eip.Billing{
		PaymentTiming: "Postpaid",
		BillingMethod: "ByTraffic",
	}
	args := &eip.CreateEipArgs{
		BandwidthInMbps: 1000,
		Billing:         bill,
		Name:            lb.Name,
	}
	glog.V(4).Infof("CreateEip:  %v", args)
	ip, err := bc.clientSet.Eip().CreateEip(args)
	if err != nil {
		return "", err
	}
	argsGet := eip.GetEipsArgs{
		Ip: ip,
	}
	eips, err := bc.clientSet.Eip().GetEips(&argsGet)
	if err != nil {
		return "", err
	}
	if len(eips) > 0 {
		eipStatus := eips[0].Status
		for index := 0; (index < 10) && (eipStatus != "available"); index++ {
			glog.V(4).Infof("Eip: %s is not available, retry:  %d", ip, index)
			time.Sleep(10 * time.Second)
			eips, err := bc.clientSet.Eip().GetEips(&argsGet)
			if err != nil {
				return "", err
			}
			eipStatus = eips[0].Status
		}
		glog.V(4).Infof("Eip status is: %s", eipStatus)
	}
	lb.Status = "unknown" //add here to do loop
	for index := 0; (index < 10) && (lb.Status != "available"); index++ {
		glog.V(4).Infof("BLB: %s is not available, retry:  %d", lb.BlbId, index)
		time.Sleep(10 * time.Second)
		newlb, exist, err := bc.getBCELoadBalancerById(lb.BlbId)
		if err != nil {
			glog.V(4).Infof("getBCELoadBalancer error: %s", lb.BlbId)
			return "", err
		}
		if !exist {
			glog.V(4).Infof("getBCELoadBalancer not exist: %s", lb.BlbId)
			return "", fmt.Errorf("BLB not exists:%s", lb.BlbId)
		}
		lb = newlb
		glog.V(4).Infof("BLB status is : %s", lb.Status)
	}
	argsBind := &eip.BindEipArgs{
		Ip:           ip,
		InstanceId:   lb.BlbId,
		InstanceType: eip.BLB,
	}
	glog.V(4).Infof("BindEip:  %v", argsBind)
	glog.V(4).Infof("Bind BLB: %v", lb)
	err = bc.clientSet.Eip().BindEip(argsBind)
	if err != nil {
		glog.V(4).Infof("BindEip error: %v", err)
		return ip, err
	}
	lb.PublicIp = ip
	glog.V(4).Infof("createEIP: lb.PublicIp is %s", lb.PublicIp)
	return ip, nil
}

func (bc *BCECloud) deleteEIP(ip string) error {
	argsGet := eip.GetEipsArgs{
		Ip: ip,
	}
	eips, err := bc.clientSet.Eip().GetEips(&argsGet)
	if err != nil {
		return err
	}
	if len(eips) > 0 {
		eipStatus := eips[0].Status
		for index := 0; (index < 10) && (eipStatus != "available"); index++ {
			glog.V(4).Infof("Eip: %s is not available, retry:  %d", ip, index)
			time.Sleep(10 * time.Second)
			eips, err := bc.clientSet.Eip().GetEips(&argsGet)
			if err != nil {
				return err
			}
			eipStatus = eips[0].Status
		}
	}
	args := eip.EipArgs{
		Ip: ip,
	}
	err = bc.clientSet.Eip().DeleteEip(&args)
	if err != nil {
		return err
	}
	return nil
}

func (bc *BCECloud) waitForLoadBalancer(lb *blb.LoadBalancer) (*blb.LoadBalancer, error) {
	for index := 0; (index < 10) && (lb.Status != "available"); index++ {
		glog.V(4).Infof("BLB: %s is not available, retry:  %d", lb.BlbId, index)
		time.Sleep(10 * time.Second)
		newlb, exist, err := bc.getBCELoadBalancerById(lb.BlbId)
		if err != nil {
			glog.V(4).Infof("getBCELoadBalancer error: %s", lb.BlbId)
			return newlb, err
		}
		if !exist {
			glog.V(4).Infof("getBCELoadBalancer not exist: %s", lb.BlbId)
			return newlb, fmt.Errorf("BLB not exists:%s", lb.BlbId)
		}
		lb = newlb
		glog.V(4).Infof("BLB status is : %s", lb.Status)
	}

	return lb, nil
}

func (bc *BCECloud) getVpcInfoForBLB() (string, string, error) {
	// get prefer vpc info
	ins, err := bc.clientSet.Cce().ListInstances(bc.ClusterID)
	if err != nil {
		return "", "", err
	}
	if len(ins) == 0 {
		return "", "", fmt.Errorf("getVpcInfoForBLB failed since instance num is zero")
	}
	vpcId := ins[0].VpcId
	subnetId := ins[0].SubnetId

	// check subnet
	subnet, err := bc.clientSet.Vpc().DescribeSubnet(subnetId)
	if err != nil {
		return "", "", fmt.Errorf("DescribeSubnet failed: %v", err)
	}
	if subnet.SubnetType == "BCC" {
		return vpcId, subnetId, nil
	}

	// get subnet list and choose preferred one
	params := make(map[string]string, 0)
	params["vpcId"] = subnet.VpcID
	subnets, err := bc.clientSet.Vpc().ListSubnet(params)
	if err != nil {
		return "", "", fmt.Errorf("ListSubnet failed: %v", err)
	}
	for _, subnet := range subnets {
		if subnet.Name == "系统预定义子网" {
			return subnet.VpcID, subnet.SubnetID, nil
		}
		if subnet.Name == "CCE-Reserve" {
			return subnet.VpcID, subnet.SubnetID, nil
		}
	}

	// create one
	currentCidr := subnet.Cidr
	for { // loop
		_, cidr, err := net.ParseCIDR(currentCidr)
		if err != nil {
			return "", "", fmt.Errorf("ParseCIDR failed: %v", err)
		}
		mask, _ := cidr.Mask.Size()
		nextCidr, notExist := util.NextSubnet(cidr, mask)
		if notExist {
			return "", "", fmt.Errorf("NextSubnet failed: %v", err)
		}
		currentCidr = nextCidr.String()
		createSubnetArgs := &vpc.CreateSubnetArgs{
			Name:       "CCE-Reserve",
			ZoneName:   subnet.ZoneName,
			Cidr:       nextCidr.String(),
			VpcID:      subnet.VpcID,
			SubnetType: "BCC",
		}
		newSubnetId, err := bc.clientSet.Vpc().CreateSubnet(createSubnetArgs)
		if err != nil {
			glog.V(4).Infof("CreateSubnet failed: %v, will try again.", err)
			time.Sleep(3 * time.Second)
			continue
		}
		return subnet.VpcID, newSubnetId, nil
	}
}
